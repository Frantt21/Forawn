// settings.dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:window_manager/window_manager.dart';
import 'main.dart' show checkForUpdate;
import 'package:flutter_acrylic/flutter_acrylic.dart' as acrylic;

typedef TextGetter = String Function(String key, {String? fallback});
typedef LanguageSelector = Future<void> Function(String code);
const String _prefEffectKey = 'window_effect';
const String _prefColorKey = 'window_color';
const String _prefDarkKey = 'window_dark';

extension StringCapitalization on String {
  String capitalize() {
    if (isEmpty) return this;
    return this[0].toUpperCase() + substring(1);
  }
}

class SettingsScreen extends StatefulWidget {
  final String currentLang;
  final TextGetter getText;
  final LanguageSelector onSelectLanguage;
  final Future<void> Function(acrylic.WindowEffect effect, Color color, {bool dark}) onChangeWindowEffect;
  const SettingsScreen({
    super.key,
    required this.currentLang,
    required this.getText,
    required this.onSelectLanguage,
    required this.onChangeWindowEffect,
  });

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> with WindowListener {
  final Map<String, String> languages = {
    'es': 'Español',
    'en': 'English',
    'ru': 'Русский',
    'pl': 'Polski',
    'de-CH': 'Deutsch (CH)',
    'zh': '中文',
    'ja': '日本語',
    'ko': '한국어',
    'pt': 'Português',
    'fr': 'Français',
  };

  String? _saving;
  bool _nsfw = false;
  static const _nsfwKey = 'nsfw_enabled';
  static const _preferredLangKey = 'preferred_lang';
  String? _selectedLang;
  SharedPreferences? _prefs;

  bool _langMenuOpen = false;
  bool _langHovered = false;
  bool _effectMenuOpen = false;
  bool _effectHovered = false;

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _selectedLang = widget.currentLang;
    _loadPrefs();
    _loadVisualPrefs();
  }

  void _loadVisualPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    final effectName = prefs.getString(_prefEffectKey) ?? 'acrylic';
    final colorValue = prefs.getInt(_prefColorKey) ?? 0xCC222222;
    final dark = prefs.getBool(_prefDarkKey) ?? true;

    setState(() {
      _selectedEffectLabel = effects.entries.firstWhere((e) => e.value.name == effectName, orElse: () => effects.entries.first).key;
      _selectedColor = Color(colorValue);
      _darkMode = dark;
    });
  }

  @override
  void didUpdateWidget(covariant SettingsScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.currentLang != widget.currentLang) {
      setState(() => _selectedLang = widget.currentLang);
    }
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  Future<void> _loadPrefs() async {
    try {
      _prefs ??= await SharedPreferences.getInstance();
      final enabled = _prefs!.getBool(_nsfwKey) ?? false;
      final savedLang = _prefs!.getString(_preferredLangKey);
      if (!mounted) return;
      setState(() {
        _nsfw = enabled;
        if (savedLang != null && savedLang.isNotEmpty) _selectedLang = savedLang;
      });
    } catch (_) {}
  }

  Future<void> _showEffectsMenu(BuildContext context, RenderBox rb) async {
    _effectMenuOpen = true;
    setState(() {});
    final topLeft = rb.localToGlobal(Offset.zero);
    final items = effects.keys.map((key) {
      final label = get('effect_$key', fallback: key.capitalize());
      return PopupMenuItem<String>(
        value: key,
        child: Text(label),
      );
    }).toList();

    final selected = await showMenu<String>(
      context: context,
      position: RelativeRect.fromLTRB(
        topLeft.dx,
        topLeft.dy + rb.size.height,
        topLeft.dx + rb.size.width,
        topLeft.dy,
      ),
      items: items,
      color: Colors.grey[900],
    );

    _effectMenuOpen = false;
    setState(() {});

    if (selected != null && selected != _selectedEffectLabel) {
      setState(() => _selectedEffectLabel = selected);
      final effect = effects[selected]!;
      await widget.onChangeWindowEffect(effect, _selectedColor, dark: _darkMode);
    }
  }


  Future<void> _toggleNsfw(bool value) async {
    try {
      _prefs ??= await SharedPreferences.getInstance();
      await _prefs!.setBool(_nsfwKey, value);
      if (!mounted) return;
      setState(() => _nsfw = value);
    } catch (_) {}
  }

  Future<void> _persistPreferredLang(String code) async {
    try {
      _prefs ??= await SharedPreferences.getInstance();
      await _prefs!.setString(_preferredLangKey, code);
    } catch (_) {}
  }

  Future<void> _selectLanguage(String code) async {
    if (_saving != null) return;
    setState(() {
      _saving = code;
      _selectedLang = code;
    });

    try {
      await widget.onSelectLanguage(code);
      await _persistPreferredLang(code);
      if (!mounted) return;
      Navigator.pop(context, code);
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(widget.getText('error_saving', fallback: 'Error saving language'))),
      );
    } finally {
      if (mounted) setState(() => _saving = null);
    }
  }

  Future<void> _minimize() async => await windowManager.minimize();
  Future<void> _maximizeRestore() async {
    final isMax = await windowManager.isMaximized();
    if (isMax) {
      await windowManager.unmaximize();
    } else {
      await windowManager.maximize();
    }
  }

  // Future<void> _close() async => await windowManager.close();

  Future<void> _showLanguageMenu(BuildContext context, RenderBox renderBox) async {
    final offset = renderBox.localToGlobal(Offset.zero);
    final size = renderBox.size;
    setState(() {
      _langMenuOpen = true;
      _langHovered = true;
    });

    final selected = await showMenu<String>(
      context: context,
      position: RelativeRect.fromLTRB(offset.dx, offset.dy + size.height, offset.dx + size.width, offset.dy),
      items: languages.entries
          .map((e) => PopupMenuItem<String>(
                value: e.key,
                child: Text(e.value),
              ))
          .toList(),
      elevation: 4,
      color: Colors.grey[900],
    );

    setState(() {
      _langMenuOpen = false;
      _langHovered = false;
    });

    if (selected != null) {
      _selectLanguage(selected);
    }
  }

    String _selectedEffectLabel = 'acrylic';
    Color _selectedColor = const Color(0xCC222222);
    bool _darkMode = true;

    final Map<String, acrylic.WindowEffect> effects = {
      'acrylic': acrylic.WindowEffect.acrylic,
      'mica': acrylic.WindowEffect.mica,
      'solid': acrylic.WindowEffect.solid,
      'transparent': acrylic.WindowEffect.transparent,
    };

  @override
  Widget build(BuildContext context) {
    final get = widget.getText;
    final Color scaffoldBg = Colors.transparent;

    final Map<String, acrylic.WindowEffect> effects = {
      'acrylic': acrylic.WindowEffect.acrylic,
      'mica': acrylic.WindowEffect.mica,
      'solid': acrylic.WindowEffect.solid,
      'transparent': acrylic.WindowEffect.transparent,
    };

    final theme = Theme.of(context).copyWith(
      splashFactory: NoSplash.splashFactory,
      highlightColor: Colors.transparent,
      hoverColor: Colors.transparent,
      focusColor: Colors.transparent,
    );

    final borderColor = (_langMenuOpen || _langHovered) ? Colors.deepPurpleAccent : Colors.white.withOpacity(0.04);

    return Theme(
      data: theme,
      child: Scaffold(
        backgroundColor: scaffoldBg,
        body: Column(
          children: [
            GestureDetector(
              behavior: HitTestBehavior.translucent,
              onPanStart: (_) => windowManager.startDragging(),
              child: Container(
                height: 42,
                padding: const EdgeInsets.symmetric(horizontal: 10),
                color: Colors.transparent,
                child: Row(
                  children: [
                    SizedBox(
                      width: 36,
                      height: 36,
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(8),
                        child: Container(
                          color: Colors.black26,
                          alignment: Alignment.center,
                          child: const Icon(Icons.settings, color: Colors.purpleAccent),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        get('setting_tittle', fallback: 'Settings'),
                        style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
                      ),
                    ),
                    IconButton(
                      tooltip: get('minimize', fallback: 'Minimize'),
                      icon: const Icon(Icons.remove, size: 18),
                      onPressed: _minimize,
                    ),
                    IconButton(
                      tooltip: get('maximize', fallback: 'Maximize'),
                      icon: const Icon(Icons.crop_square, size: 18),
                      onPressed: _maximizeRestore,
                    ),
                    IconButton(
                      tooltip: get('back', fallback: 'Back'),
                      icon: const Icon(Icons.arrow_back, size: 18),
                      onPressed: () => Navigator.pop(context),
                    ),
                  ],
                ),
              ),
            ),

            Expanded(
              child: SafeArea(
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
                    Text(get('lang_select', fallback: 'Select language:'), style: const TextStyle(fontSize: 16)),
                    const SizedBox(height: 12),
                    MouseRegion(
                      onEnter: (_) {
                        setState(() => _langHovered = true);
                      },
                      onExit: (_) {
                        if (!_langMenuOpen) setState(() => _langHovered = false);
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                        decoration: BoxDecoration(
                          color: Colors.black12,
                          borderRadius: BorderRadius.circular(10),
                          border: Border.all(color: borderColor),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.language),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Builder(builder: (rowContext) {
                                return GestureDetector(
                                  behavior: HitTestBehavior.translucent,
                                  onTap: () {
                                    final rb = rowContext.findRenderObject() as RenderBox?;
                                    if (rb != null) _showLanguageMenu(rowContext, rb);
                                  },
                                  child: Row(
                                    children: [
                                      Expanded(child: Text(languages[_selectedLang] ?? languages[widget.currentLang]!)),
                                      const Icon(Icons.arrow_drop_down),
                                    ],
                                  ),
                                );
                              }),
                            ),
                            const SizedBox(width: 12),
                            if (_saving != null)
                              const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))
                            else if (widget.currentLang == (_selectedLang ?? widget.currentLang))
                              const Icon(Icons.check, color: Colors.green),
                          ],
                        ),
                      ),
                    ),

                    const SizedBox(height: 16),

                    Text(get('window_style', fallback: 'Estilo de ventana'), style: const TextStyle(fontSize: 16)),
                    const SizedBox(height: 12),

                    MouseRegion(
                      onEnter: (_) => setState(() => _effectHovered = true),
                      onExit: (_) {
                        if (!_effectMenuOpen) setState(() => _effectHovered = false);
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                        decoration: BoxDecoration(
                          color: Colors.black12,
                          borderRadius: BorderRadius.circular(10),
                          border: Border.all(color: borderColor),
                        ),
                        child: Row(
                          children: [
                            const Icon(Icons.format_paint),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Builder(builder: (rowContext) {
                                return GestureDetector(
                                  behavior: HitTestBehavior.translucent,
                                  onTap: () {
                                    final rb = rowContext.findRenderObject() as RenderBox?;
                                    if (rb != null) _showEffectsMenu(rowContext, rb);
                                  },
                                  child: Row(
                                    children: [
                                      Expanded(
                                        child: Text(
                                          // Mostrar label legible: usa la key seleccionada o etiqueta por defecto
                                          _selectedEffectLabel != null
                                              ? get('effect_${_selectedEffectLabel!}', fallback: _selectedEffectLabel!.capitalize())
                                              : get('effect_default', fallback: 'Seleccionar efecto'),
                                        ),
                                      ),
                                      const Icon(Icons.arrow_drop_down),
                                    ],
                                  ),
                                );
                              }),
                            ),
                            const SizedBox(width: 12),
                            if (_saving != null)
                              const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2))
                            else if (_selectedEffectLabel == _currentEffectKey) // ajusta según tus nombres de campo
                              const Icon(Icons.check, color: Colors.green),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),

                    ElevatedButton.icon(
                      icon: const Icon(Icons.color_lens),
                      label: Text(get('apply_flat_color', fallback: 'Aplicar fondo plano')),
                      onPressed: () async {
                        _selectedColor = const Color(0xFF1E1E1E);
                        _darkMode = true;
                        _selectedEffectLabel = 'solid';
                        final effect = effects[_selectedEffectLabel]!;
                        await widget.onChangeWindowEffect(effect, _selectedColor, dark: _darkMode);
                        setState(() {}); // actualiza visual
                      },
                    ),
                    const SizedBox(height: 24),

                    SwitchListTile(
                      title: Text(get('nsfw_toggle', fallback: 'Activar sección NSFW')),
                      value: _nsfw,
                      onChanged: (v) => _toggleNsfw(v),
                      secondary: const Icon(Icons.warning),
                    ),
                    const SizedBox(height: 24),

                    ElevatedButton.icon(
                      icon: const Icon(Icons.system_update),
                      label: Text(get('check_update', fallback: 'Verificar actualización')),
                      onPressed: () => checkForUpdate(context, get),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.transparent,
                        foregroundColor: Colors.white,
                        shadowColor: Colors.transparent,
                        elevation: 0,
                        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 12),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                        side: const BorderSide(color: Colors.white, width: 1),
                      ).merge(
                        ButtonStyle(
                          overlayColor: WidgetStateProperty.resolveWith<Color?>((states) {
                            if (states.contains(WidgetState.pressed)) return Colors.white.withOpacity(0.10);
                            if (states.contains(WidgetState.hovered)) return Colors.white.withOpacity(0.06);
                            if (states.contains(WidgetState.focused)) return Colors.white.withOpacity(0.06);
                            return null;
                          }),
                        ),
                      ),
                    ),
                  ]),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
